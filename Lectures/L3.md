# 플랫폼 게임제작

## 오브젝트간 충돌 감지 / Physics
 
### Physics
![unity_physics](https://user-images.githubusercontent.com/48755297/87005041-5e388000-c1f9-11ea-9543-f5c947dc4dab.png)
>유니티에 표준으로 속해 있는 물리엔진.
 
### 물리엔진
>오브젝트를 물리 동작에 맞춰 움직임을 구현하는 시뮬레이션용 라이브러리
>오브젝트의 질량, 마찰 계수, 중력 등을 고려해 움직임을 자동으로 계산 -> 사실적인 동작을 쉽게 구현
 
### 스크립트 vs Physics

  #### 스크립트로 제어 
  ![unity_script](https://user-images.githubusercontent.com/48755297/87005346-d2732380-c1f9-11ea-89b8-8f6aed766e1a.jpg)
  > 복잡하고 관련된 코딩능력(C#) 필요  
  > 비자연스러운 움직임  
  
  #### Physics로 제어 
  ![unity_physics2](https://user-images.githubusercontent.com/48755297/87005446-f8002d00-c1f9-11ea-8b89-cacf2a725ef8.png)
  > 상대적으로 짧고 간단한 코딩   
  > 자연스러운 움직임   
  > 유니티의 다른 기능들과 최적화   


## 바로 구현해보자!

### 플랫폼 게임만들기

### 카메라 설정

카메라 설정시 position Z가 중요 → 카메라가 오브젝트보다 앞에있으면(z값이 크면) 오브젝트가 게임 화면에 나타나지 않을 수 있다.

### 기본 설정 - Sprite 불러오기

<!--사진 첨부하기-->

Drag&Drop으로 쉽게 이미지 파일을 옮길 수 있다.

#### **Sprite 정보창**

**SpriteMode : Multiple**    이미c지 자를지 여부 설정

**SpriteEditor**    세부 sprite 설정용

**FilterMode : Point**     비트이미지 뭉개지지 않게 설정 가능
<!--사진 첨부하기-->

#### **SpriteEditor란**

**Grid By Cell Size** : 각 sprite가 일정한 크기일 경우 이용

**Automatic** : 각 sprite를 원하는 크기로 따로따로 자를 경우 이용

일정한 크기로 자르고 싶으므로 grid by cell size로 **X=96, Y=128**로 크기설정  
<!--사진 첨부하기-->

하나의 이미지를 손쉽게 잘라서 관리할 수 있다.

> 주의 :  spriteEditor 실행 안될시 PacakageManager이용하기

<!--사진 첨부하기-->

#### 오브젝트만들기

<!--사진 첨부하기-->

원하는 이미지 파일을 Scene에 Drag&Drop으로 손쉽게 오브젝트를 만들 수 있다.



### 애니메이션 적용   
<!-- 채우기 -->

### 움직이기   
스크립트 생성 -> 다음의 코드 추가

``` c
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using UnityEngine;

public class PlayerMoveController : MonoBehaviour
{
    public float speed = 5.0f;

    void Update()
    {
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        Move(h, v);
        
    }

    void Move(float h, float v)
    {
        Vector3 dir = h * Vector3.right + v * Vector3.up;

        this.transform.Translate(dir * speed * Time.deltaTime);
    }
    
}

```
> 참고
1. Input.GetAxis(string name)

-1.0f 부터 1.0f 까지의 범위의 값을 반환한다. 즉, 부드러운 이동이 필요한 경우에 사용된다.


2. Input.GetAxisRaw(string name)

-1, 0, 1 세 가지 값 중 하나가 반환된다. 키보드 값을 눌렀을 때 즉시 반응해야한다면 GetAxisRaw를 사용하면 된다.

### 점프


바닥 Sprite를 만들고 rigidbody2d, box collider 추가. Player에게도 rigidbody2d, circle collider 추가.  

![image](https://user-images.githubusercontent.com/48755297/87277809-0910ad00-c51e-11ea-9748-ef0d045e4548.png)

![image](https://user-images.githubusercontent.com/48755297/87277766-f007fc00-c51d-11ea-9df0-ed8fc3ae36ad.png)

``` 
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using UnityEditorInternal;
using UnityEngine;

public class PlayerMoveController : MonoBehaviour
{
    public float speed = 5.0f;
    public float jumpPower = 5.0f;
    public Rigidbody2D rigid;
    float h;
    float v;

    bool isjumping;

    void Awake()
    {
        rigid = GetComponent<Rigidbody2D>();
    }

    void Update()
    {
        h = Input.GetAxis("Horizontal");

    }

    void FixedUpdate()
    {
        Move();
        Jump();
    }

    void Move()
    {
        Vector3 dir = h * Vector3.right;

        this.transform.Translate(dir * speed * Time.deltaTime);
    }

    void Jump()
    {
        if (Input.GetButton("Jump"))
        {
            if (!isjumping)
            {
                //바닥과 붙어있는 상태
                isjumping = true;
                rigid.AddForce(Vector2.up * jumpPower, ForceMode2D.Impulse);
            }
            else
            {
                //공중에 떠있는 상태
                return;
            }
        }

    }

    void OnCollisionEnter2D(Collision2D col)
    {
        if (col.gameObject.CompareTag("Ground"))
        {
            isjumping = false;
        }
    }
    
}

```



### 충돌

#### 충돌이 일어나기 위한 조건
> 두 GameObject가 모두 Collider Component를 가지고 있어야 합니다.  
> 둘 중 하나는 Rigidbody Component를 가지고 있어야 합니다. __(2개 모두 있어도 가능합니다.)__

#### Rigidbody 2D 적용
> Rigidbody란 강체(剛體)라는 뜻으로, 유니티에서 __질량, 중력__ 등 물리적인 기능을 가지게 해주는 것.
<!-- 적용법 첨부 -->

#### Collider 2D 적용
> Collider란 오브젝트의 충돌 __'범위'__ 를 지정해주는 것.
<!-- 적용법 첨부 -->

#### 충돌한다!
<!-- 충돌하는 사진 첨부 -->

#### 충돌하면 그 다음엔?

>void OnCollisionEnter(Collision col) {  }  
>충돌 발생 시점에 수행할 함수  

>void OnCollisionStay(Collision col) {  }  
>충돌 발생 중에 수행할 함수  

>void OnCollisionExit(Collision col) {  }  
>충돌이 끝났을 시에 수행할 함수  

<!-- 채우기 -->



### 씬(Scene) 관리하기


![Scene_1](https://user-images.githubusercontent.com/48755297/87015951-0b66c480-c209-11ea-962b-55a983459f47.PNG)
##### Scene을 모두 추가해준다.
![Scene_2](https://user-images.githubusercontent.com/48755297/87015953-0bff5b00-c209-11ea-8038-d737b6266cd8.PNG)
![Scene_3](https://user-images.githubusercontent.com/48755297/87015957-0c97f180-c209-11ea-8dd3-64ce89ebf8bb.PNG)
##### Scene의 순서를 바꿀 수 있다.
![Scene_4](https://user-images.githubusercontent.com/48755297/87015958-0d308800-c209-11ea-9f3e-cc88a625eee5.PNG)


#### SceneManagement 추가하기

File - Build Settings 에서 Scene을 추가한다.

```c#
using UnityEngine.SceneManagement;

```

#### Scnene 이동하는 코드
```c#
SceneManager.LoadScene("Scene_Play");
```
>매개변수에는 string으로 된 Scnene의 이름 또는 씬의 번호가 들어간다.

